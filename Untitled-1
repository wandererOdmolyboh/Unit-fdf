# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Untitled-1                                         :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: dmolyboh <dmolyboh@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2019/02/02 16:32:53 by wanderer          #+#    #+#              #
#    Updated: 2019/02/04 15:42:49 by dmolyboh         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#include "fdf.h"
#include <math.h>
#include <mlx.h>
#include <stdlib.h>

int func_parse_stroke (t_point **matrix, char *string);
char *ft_comma(char *string)
{
	int i;

	i = 0;

	while(string[i] && (string[i] >= '0' && string[i] <= '9' ))
		i++;
	if (string[i] != ',')
		return (ft_strdup("0xFFFFFF"));
	else
		return (ft_strdup(string + i + 1)); 
}


int vslidate_str(char *buf)
{
    int i;

    i = 0;
    while(buf[i])
    {
        if (buf[i] == ' ' || buf[i] == '\t' || (buf[i] >= '0' && buf[i] <= '9')
        || (buf[i] >= 'A' && buf[i] <= 'F')
        || buf[i] == 'x' || buf[i] == ',' || buf[i] == '\n')
            i++;
        else
            return(-1);
        i++;
    }
    return (0);
}

int validate_hard(char *buf)
{
    int y;
    int c_len_num;

    y = 0;
    while(buf[y])
    {
        c_len_num = 0;
        if (buf[y] == 'x')
        {
            if (buf[y] && buf[y - 1]!= '0' && buf[y - 2]!= ',')
                return (3);
            while(buf[y] && ((buf[y]>= 'A' && buf[y] <= 'F') 
            || (buf[y] >= '0' && buf[y] <= '9' )))
                c_len_num++;
            if (c_len_num < 2 || c_len_num > 6)
                return (3);
            c_len_num = 0;
        }
        y++;
    }
        if (buf[y - 1] == ' ')
            return (3);
    return (0);
}




double value(double x1, double x2)
{
	int rez;
	rez = x2 - x1;
	if (rez < 0)
		rez = -rez;
	return (rez);
}

void line(void *mlx_ptr, void *win_ptr, double x1, double y1, double x2, double y2)
{
	///структуры!
    double dx;
    double dy;
    double lengthX;
    double lengthY;
    double length;
	double x;
	double y;
	double d;

	dx = (x2 - x1 >= 0 ? 1 : -1);
	dy = (y2 - y1 >= 0 ? 1 : -1);
	lengthX = value(x1, x2);
	lengthY = value(y1, y2);
	length = (lengthX > lengthY ? lengthX : lengthY) + 1;
    if (length == 1)
        mlx_pixel_put(mlx_ptr, win_ptr,  x1,   y1, 0x111000);
    x = x1;
    y = y1;
	//функция
	if (lengthY <= lengthX)
    {
        d = -lengthX;
        while(length--)
        {
            mlx_pixel_put(mlx_ptr, win_ptr,  x,   y, 0xFF3333);
            x += dx;
            d += 2 * lengthY;
            if (d > 0)
            {
                d -= 2 * lengthX;
                y += dy;
            }
        }
    }
    else
    {
        d = - lengthY;
        while(length--)
        {
            mlx_pixel_put(mlx_ptr, win_ptr,  x,   y, 0xFF3333);
            y += dy;
            d += 2 * lengthX;
            if (d > 0)
            {
                d -= 2 * lengthY;
                x += dx;
            }
        }
    }
}

void myabe(t_point **matrix)
{
	void *mlx_ptr;
	void *win_ptr;
	double angl = 0.2;
	int x;
	int y;
	y = 0;
	mlx_ptr = mlx_init();
	win_ptr = mlx_new_window (mlx_ptr,V, H, "test" );
	while (y < 12)
	{
		x = 0;
		while (x < 19)
		{
			matrix[y][x].y = (matrix[y][x].d_y * cos(angl) + matrix[y][x].d_z * sin(angl));

			matrix[y][x].x = (-matrix[y][x].d_x * sin(angl) + matrix[y][x].d_z * cos(angl));
			mlx_pixel_put(mlx_ptr, win_ptr, matrix[y][x].x, matrix[y][x].y, 0xFFF111);
		 printf("\ny == %f x == %f z == %f \nd_y == %f d_x == %f d_z == %f\n", matrix[y][x].y, matrix[y][x].x, matrix[y][x].z, matrix[y][x].d_y, matrix[y][x].d_x, matrix[y][x].d_z);
			x++;
		}
		y++;
	}
	mlx_loop(mlx_ptr);
}


int func_parse_stroke (t_point **matrix, char *string)
{
	int i;
	int x;
	int y;

	x = 0;
	y = 0;
	i = 0;
	if (vslidate_str(string) || validate_hard(string))
		return (-1);
	while(string[i])
	{
		while(string[i] == ' ' || string[i] == '\t')
			i++;
		if (string[i] == '\n')
		{
			// point->ch = 1; //////////////////////////////////////////////////
			while(string[i] == '\n')
				i++;
			y++;
			x = 0;
		}
		if ((string[i] >= '0' && string[i] <= '9'))
		{
			matrix[y][x].d_y = x;
			matrix[y][x].d_y = y;
			matrix[y][x].d_z = ft_atoi(&string[i]);
			matrix[y][x].color = ft_comma(&string[i]);
			// printf("y == %d, x == %d\n", y, x);
			x++;
			i++;
		}
		while(string[i] && ( (string[i] >= '0' && string[i] <= '9') || string[i] ==',' || 
		(string[i] >= 'A' && string[i] <= 'F')))
			i++;		

	// myabe(tmp);

	}
	// printf("\n%f\n", matrix[3][3].d_z);
	myabe(matrix);
	return (0);
}


// int func_parse_stroke (char *string, t_point **matrix)
// {
// 	if (*point == NULL && (*point = ft_memalloc(sizeof(t_point))))
// 		return (NULL);
// 	return (*point);
// }

int	creat_matrix(char *line)
{
	t_point **matrix;
	t_point *pointer;
	int n;
	int y;

	y = 0;
	n = count_new_line(line);
	matrix = (t_point **)malloc(sizeof(t_point *) * n);
	matrix[n] = NULL;
	while(y < 12)
	{
		matrix[y] = (t_point*)malloc(sizeof(t_point) * 19);
		y++;
	}
	func_parse_stroke(matrix ,line);
	
	return (0);
}

int count_new_line(char *line)
{
    int count;
    int i;

    i = 0;
    count = 0;
    while (line[i++])
        if(line[i] == '\n')
            count++;
    return (count);
}

int func_read(int fd)
{
	char    *line = NULL;
	int     len;
	char    *buf;
	char	*leaks;

	if ((buf = (char *)malloc(BUFF_SIZE + 1)) == NULL)
		return ((-1));
	while ((len = read(fd, buf, BUFF_SIZE)) > 0)
	{
		buf[len] = '\0';
		line = ft_strjoin(line, buf);
	}
	free(buf);
	creat_matrix(line);
	// if (func_parse_stroke(line) != 0)
	// 	return (-2);
	free(line);
	return (0);
}

int main(int argc, char **argv)
{
	if (argc == 2)
	{
		argc = open(argv[1], O_RDONLY);
		if ((argc = func_read(argc)) != 0)
			return  (error_output(argv, FALSE));// add to func params argc
		close(argc);
	}
	else 
		return (error_output(argv, TRUE));
	return (0);
}